#pragma once

#include <array>
#include <cstdint>
#include <limits>
#include <vector>

namespace rc {

class RandomEmptyException : public std::runtime_error {
public:
  inline RandomEmptyException(size_t size, size_t index)
      : std::runtime_error("") {
    snprintf(msg_buf, kBufSize, "Size: %zu, index: %zu", size, index);
  };
  inline virtual const char *what() const throw() { return msg_buf; };

private:
  static constexpr size_t kBufSize = 50;
  char msg_buf[kBufSize];
};

// TODO(siedentop): total hack. also defined in detail/Property.h
using RandomData = std::vector<uint8_t>;

/// Implementation of a splittable random generator as described in:
///   Claessen, K. och Palka, M. (2013) Splittable Pseudorandom Number
///   Generators using Cryptographic Hashing.
class Random {
  friend bool operator==(const Random &lhs, const Random &rhs);
  friend bool operator<(const Random &lhs, const Random &rhs);
  friend std::ostream &operator<<(std::ostream &os, const Random &random);

  template <typename Iterator>
  friend Iterator serialize(const Random &random, Iterator output);

  template <typename Iterator>
  friend Iterator deserialize(Iterator begin, Iterator end, Random &output);

public:
  /// Key type
  using Key = std::array<uint64_t, 4>;

  /// Type of a generated random number.
  using Number = uint64_t;

  /// Constructs a Random engine with a `{0, 0, 0, 0}` key.
  /// Nope, now it constructs an invalid engine.
  Random();

  /// Constructs a Random engine from a full size 256-bit key.
  // Random(const Key &key);

  /// Constructs a Random engine from a 64-bit seed.
  // Random(uint64_t seed);

  /// Constructs a 'Random' engine from the data generated by libFuzzer
  Random(const RandomData &data, size_t index = 1);

  /// Splits this generator into to separate independent generators. The first
  /// generator will be assigned to this one and the second will be returned.
  Random split();

  /// Returns the next random number. Both `split` and `next` should not be
  /// called on the same state.
  Number next();

private:
  using Block = std::array<uint64_t, 4>;

  using Bits = uint64_t;
  static constexpr auto kBits = std::numeric_limits<Bits>::digits;

  using Counter = uint64_t;
  static constexpr auto kCounterMax = std::numeric_limits<Counter>::max();

  /// No more 'randomness' in the non-random engine.
  inline bool empty() const { return m_index >= m_data.size(); }

  RandomData m_data;
  /// Look into m_data as a tree
  size_t m_index;
};

bool operator!=(const Random &lhs, const Random &rhs);

} // namespace rc

namespace std {

template <>
struct hash<rc::Random> {
  using argument_type = rc::Random;
  using result_type = std::size_t;

  std::size_t operator()(const rc::Random &r) const {
    return static_cast<std::size_t>(rc::Random(r).next());
  }
};

} // namespace std

#include "Random.hpp"
